#  Numbers —— 数字

<table><tr><td bgcolor=Black><font size=5 face="consolas" color=white><center>————————————————CopyRigth: Lingmux-2020————————————————</center></font></td></tr></table>

### 整数

Python中的变量不需要声明类型

解释器会自己进行推断，也就在某种程度上导致了Python的运行效率不理想

Python中的“数字”大约有`int`和`float`两种

但是本质上`int`和`float`完全就是字面意思，整数和浮点数，其精度是解释器自己推断的

其他语言中的整数也许分为好多种，比如`long`,`short`,`long long`，但是python中的整数只有`int`

你可以在idle/python3 command line中尝试以下代码：

```python
short_int = 1
int_ = 65536
int_long = 465746846467687687
print(type(short_int), type(int_), type(int_long)) # type函数可以获取变量的类型，print函数用于打印
```
你会发现不论数字的大小，你得到的`type()`打印出来的结果都是`int`

你不需要考虑太多，你只需要把所有的整数视为`int`即可

其他的语言我不是很清楚，但是Python给整数的进制转换提供了良好的支持，Python的每个模块都会自动导入`builtin`这个模块，进制转换的方法就在`builtin`模块中，这个机制暂时不需要非常详细的了解

现阶段您只需要知道，当想要对一个整数进行进制转换时，可以这样做

```python
int_org = 256
# 转换为二进制数字
bin(int_org)

# 转换为八进制数字
oct(int_org)

# 转换为10进制数字
bin_int = 0b1010
int(bin_int)

# 转换为16进制
hex(int_org)
```

上述的几个函数`bin()`, `oct()`,`int()`,`hex()`

|  函数   |               功能               |
| :-----: | :------------------------------: |
| `bin()` | 转换任意进制的整数为其2进制形式  |
| `oct()` | 转换任意进制的整数为其8进制形式  |
| `int()` | 转换任意进制的整数为其10进制形式 |
| `hex()` | 转换任意进制的整数为其16进制形式 |



可以接受不同种类的数字，你可以使用`oct()`来转化一个16进制的数字为八进制的数字，也可以用`hex()`来对二进制的数字进行转换

另外`int()`这个其实不算是一个**函数**，有点像是`int`类型的构造函数，这一部分面向对象的内容，我们会在后续的章节进行详细的阐述



另外在使用这样的函数时您可能会发现一些东西，就是`0b`， `0o`，`0x`

这样的前缀，这是一个通用的表示进制的前缀，`0b`表示二进制，因为`10`和`0b10`其实是两个数字，使用前缀的方法可以简洁高效的消除歧义

即

| 前缀 |     意义     |
| :--: | :----------: |
| `0b` |  二进制数字  |
| `0x` | 十六进制数字 |
| `0o` |  八进制数字  |

如果你还不清楚什么是进制以及进制之间如何转换，您可以参考[进制](https://zh.wikipedia.org/wiki/%E8%BF%9B%E4%BD%8D%E5%88%B6)

如何转换进制并不在Python的教程范围内，您可以参考补充文档[Play with Python 0x01_补充文档0x1 进制于进制的转换](./else/Play with Python Else0x01.md)

到这里为止，您应该明白了Python中的整数以及其进制转换



#### 一点小补充：

<table><tr><td bgcolor=Black><center><font color=66ccff  size=4>为什么有的人说Python天生适合处理大——数字？</font> </center></td></tr></table>

**阅读这一部分之前要说明一点，源码阅读并不是本教程的核心内容，如果你有C语言编程的基础，并且想要了解一些Python的机制的可以看完这个小补充，因为其中参杂了个人的见解，所以并不保证完全正确。**

这一部分的部分内容参考自[Python源码剖析](https://flaggo.github.io/python3-source-code-analysis/objects/long-object/)，如果对详细分析感兴趣的看这里

Python中储存巨大的整数的方法并不是想象中的使用更多的位，或者说，不是类似于C风格的，增加更多的位；

比如说C语言中储存`int`类型使用4bytes，也就是4*8=32bits.[What is bits? What is Bytes?补充文档0x02：Bits Bytes 傻傻分不清楚](./else/Play with Python Else0x02.md)

`int i = 1;`意味着在栈区（也就是编译器自动分配释放的内存部分）开辟出32bit的空间，存入数字1的对应的二进制数字：

`0b 0000 0000 0000 0000 0000 0000 0000 0001`

像是这样子，简单粗暴，c中的`long`或者是`long long`也是这样的原理，就是位不太一样

但是Python中储存**长**整数的方法是先把长整数按照这个格式整理出来，然后只储存$k$
$$
\sum^1_{n} (2^{PyLongSHIFT})^n  * k
$$
**PyLong_SHIFT**的数值是根据操作系统的位数来决定的，比如64位的系统就是30，否则就是15

举个栗子：

```python
9223372043297226753
```

 假设现在操作系统是64位的，PyLong_SHIFT的值就是30
$$
9223372043297226753 = 1 * (2^{30})^0 + 6 * (2^{30})^1+8*(2^{30})^2
$$
按照上述的公式来整理就是这样的

然后在内存中开辟一个数组，数组中只储存`{1,6,8}`，解析的时候就按照顺序乘以$(2^{30})^n$即可

算术的时候似乎也不需要先解析出来在运算，比如两个数字解析完都是`{1,6,8}`

那么相加就是对应的k相加就行——相加结果就是`{2,12,16}`，按照结合律算算就知道了
$$
1 * (2^{30})^0 + 6 * (2^{30})^1+8*(2^{30})^2 + 1 * (2^{30})^0 + 6 * (2^{30})^1+8*(2^{30})^2\\ 
=(1+1)*(2^{30})^0 + (6+6)*(2^{30})^1 + (8+8)(2^{30})^2\\
=2* (2^{30})^0+12 (2^{30})^1+16 (2^{30})^2
$$

加法减法可以做出来的话，乘除法更简单了，因为乘除法都是基于加减法而推导出来的。

然后在解析出来就是我们要的数字

这样看上去不太聪明，解析和打包都需要一定的时间，这样做有什么好处呢？

我个人觉得这样做的好处就是不容易出现`OverFlow`的错误，不容易发生算术溢出。得益于这种方式，Python在解析大——数字的时候更加的“得心应手”，所以为什么说Python天生就适合处理“大数字”。

所以你可以轻松的写下这样的代码：

```Python
9223372043297226753 **3 # 乘方运算： x **2 等价于 求x的平方
```

Python也可以快速给你反馈：

```Python
784637718567524438880404225052896680557050380503562059777
```

这个数字远大于C语言的 ` unsigned long long int`  的承受范围

所以Python中，一个数字所占的储存空间并不是实际上这个数字所对应的二进制的数字的空间，每增加一个$(2^{30})^n$，理论上就增加4个byte。再加上固定的一个大小（固定大小*应该*是Python中的数字包含了PyObject之类的结构，加上这些结构所占的24个bytes。)

Python Command Line中尝试代码：

```Python
>>>sys.getsizeof(0) # sys.getsizeof 和C/C++的sizeof是一个功能
24
>>>sys.getsizeof(1)
28
>>>sys.getsizeof(2 ** 30 - 1) # 不满一个2的三十次方
28
>>>sys.getsizeof(2 ** 60 - 1) # 大于2**30但小于2**60、
32
>>>sys.getsizeof(2 ** 60) # 大于2**30 ，又大于等于2**60
36
>>>sys.getsizeof(784637718567524438880404225052896680557050380503562059777) # 大于2**60，大于等于2**90
38
```

Python3.8源码中的./include/object.h中定义了`PyObject`

```C

typedef struct _object {
    _PyObject_HEAD_EXTRA; // 一个双向链表
    Py_ssize_t ob_refcnt; // 引用计数
    struct _typeobject *ob_type; // 用于标记Object属于什么类型 
} PyObject;
```



### 浮点数

您应该发现了，我用了两个节来阐述小数和浮点数，这里我想说，浮点数和小数应该是两个概念

您输入的`0.3`，在程序中会被解释为一个二进制的数字，因为其算法的问题，会出现

```python
x = 0.3
print(0.1 + 0.2 == x) # 打印出 0.1+0.2是否等于变量x
```
输出结果为
```python
False
```
的情况

亦或者

```python
x = 0.1 + 0.2
print(x)
```
输出结果为
```python
0.30000000000000004
```

的情况。

所以在这里我用两个小节来介绍在Python中的两种不同的小数表现形式

很多其他的语言中，浮点数有不同的精度，比如`float`单精度浮点数，`double`双精度浮点数，或者配合精度修饰符`long`之类的，在Python中您不需要考虑这些，这些精度上的解释和推断，都交给解释器处理

所以您只需要写

```python
example_float = 0.41
```

即可

所有的浮点数在被判断`type`的时候，都会输出为`float`



另外，您也看到了，在上述的例子中出现了`0.1 + 0.2 = 0.30000000000000004`这样的情况，所以我们判断两个浮点数的大小是否相等时(并且需要一定精度支持时)，我们需要引入一个非常小的值，一般我们称他为`EPSILON`，一般取值为`1e-8`

您可能会疑问，这个`1e-8`是个什么意思，e和后面的数字，联合起来表示$n$次方

`1e-8`即，1的-8次方，通过判断两个值相减结果是否小于1的-8次方，来判断这两个值是否相等

like this

```python
x = 0.1 + 0.2
y = 0.2 + 0.1
x - y < 1e-8
```
结果为
```python
True
```
这个例子中的x和y，都等于`0.30000000000000004`，当然可能因为电脑的操作系统，电脑的位数，和python的版本之类的和我的不一致而导致您看到的值不完全等于我写出来的这个`0.30000000000000004`，不过没关系，思路是一致的

最后，浮点数没有办法像是整数一样被`bin()`一类的函数进行进制转换，您这样做会会触发

```bash
TypeError: 'float' object cannot be interpreted as an integer
'float' object cannot be interpreted as an integer
```

的错误，这也是您在本教程中遇到的第一个`Error`，叫做`TypeError`，表示类型错误，Python 的解释器的错误归类非常完善，也非常的友好，当您不知道怎么debug的时候，可以试着直接在google搜索这个错误的内容。



好啦，Python 的浮点数就是这样，非常简单。

### 小数

看到小数，你可能会想，文章刚刚不是介绍了“小数”吗？

此小数非彼小数，这个小数又叫做$Decimal$，刚刚的那个叫浮点数$Floating Point$

浮点数是一个处理小数的机制，但是因为浮点数并不能很好地表达小数，所以在要求精度（比如银行的系统里）时，我们需要一种更加精确的数字

为了搞清楚为什么浮点数表达不清楚小数，我们举一个例子

数字3转换成二进制后为0b11，如果写成4个字节长度的整数，就是

`0b0000 0000 0000 0011`

任何一个整数都可以用一种简单方式，转换为由若干个2的指数乘以某个系数相加的形式

比如



$$
3 = 2^0 * 1 + 2^1*1
$$
亦或者
$$
7  =2^0*1+2^1*1+2^2*1
$$
具体的证明过程就不在这里阐述了

但是小数这里就很难了

0.3就不能像3一样，在转换3为二进制数字的时候，用的是2的正数次方，但是小数需要用二的负数次方
$$
2^{-1} =0.5\\
2^{-2} =0.25\\
2^{-3} =0.125
$$
要想表示0.3，可以：
$$
2^{-2} + 2^{-3}
$$
不论你用怎样的组合，你组和的值只能无限接近于0.3而不能等于0.3

而且计算机储存小数是以约定好的字节数存储的，有限的空间里储存一个无线巨大的“组合”是不可能的，所以只能退而求其次



但是为了精度，人们发明了一种新的数据类型，叫做$Decimal$

在Python中，想要使用这种Decimal，你需要先把他从标准库中导入进来，导入操作的作用机制我们以后会论述，在这里就当作是一个约定，我们先写上这样一行特殊的代码：

```python
from decimal import *

# 简单地创建一个decimal变量：
exmaple_decimal1 = Decimal("0.3")
exmaple_decimal2 = Decimal("0.1428571428571428571428571429")

# 打印出两个变量相加地值
print(exmaple_decimal1 + exmaple_decimal2)
```

decimal 模块旨在支持“无偏差，精确无舍入的十进制算术（有时称为定点数算术）和有舍入的浮点数算术”。 —— 摘自 decimal 算术规范说明

到此为止，初学阶段涉及的Decimal内容就结束了，但是Decimal不仅仅是刚刚展示地这样简单，可以参考这个

[Python3.8.5标准库介绍](https://docs.python.org/zh-cn/3/library/decimal.html)

创建一个Decimal变量涉及到了一些面向对象都内容，但是不要紧，在现阶段你可以这样创建，等你有了更多地Python基础，我们可以再回来阅读接下来地内容




### 复数

[什么叫做复数](https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6))

Python是支持复数的，实部直接使用数字表述，虚部可以用实数+`j`来表示：

在idle/python3 command line中尝试以下代码

```python
complex_example = 1 + 2j
 type(complex_example)
```

结果：

```
<class 'complex'>
```


Python为复数提供了不错的支持，包括基本的四则运算等：
```Python
1+2j + 3+4j # (4+6j)
(1+2j) ** 2 # (-3+4j)
```

复数操作并不是Python中常用的操作，比如我本人从学习使用Python以来，除了学习复数的使用以外，几乎没有用到过复数

[复数的更多文档](https://docs.python.org/3/c-api/complex.html)